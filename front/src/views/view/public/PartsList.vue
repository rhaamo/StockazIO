<template>
  <div class="add_part">
    <ViewModal
      :part="partDetails" :can-delete="false"
      @view-part-modal-closed="onPartModalClosed"
    />

    <div class="row">
      <div class="col-12">
        <ol class="breadcrumb">
          <template v-if="actualCurrentCategory && categoryId && categoryId !== '0'">
            <li class="breadcrumb-item">
              Parts by category
            </li>
            <li class="breadcrumb-item active">
              <router-link :to="{ name: 'parts-category-list', params: { categoryId: actualCurrentCategory.id, category: actualCurrentCategory } }">
                {{ actualCurrentCategory.name }}
              </router-link>
            </li>
          </template>
          <template v-else>
            <li class="breadcrumb-item active">
              <router-link :to="{ name: 'parts-list' }">
                All parts
              </router-link>
            </li>
          </template>
        </ol>
      </div>
    </div>

    <div class="row mb-3">
      <div class="col-xl-2 col-3">
        <vue-multiselect
          v-model="filter.footprint" :options="choicesFootprint"
          group-values="footprints" group-label="category" placeholder="Filter footprint"
          label="name" track-by="id" @input="filterFootprintChanged"
        />
      </div>
      <div class="col-xl-2 col-3">
        <vue-treeselect
          v-model="filter.storage" :multiple="false"
          :options="choicesStorageLocation" search-nested :default-expand-level="Infinity"
          clearable :normalizer="storagesNormalizer" no-children-text
          placeholder="Filter storage" :disable-branch-nodes="true"
          @input="filterStorageChanged"
        />
      </div>
      <div class="col-lg-2">
        <b-form-checkbox
          v-model="filter.qty"
          value="qty"
          :unchecked-value="null"
          inline
        >
          Only out of stock
        </b-form-checkbox>
      </div>
      <div class="col-lg-2">
        <b-form-checkbox
          v-model="filter.qty"
          value="qtyMin"
          :unchecked-value="null"
          inline
        >
          Only qty &lt; min
        </b-form-checkbox>
      </div>
      <div class="col-lg-2">
        <b-form-checkbox
          v-model="filter.sellable"
          value="sellable"
          :unchecked-value="false"
          inline
        >
          Only resellables
        </b-form-checkbox>
      </div>
    </div>

    <div class="row">
      <div class="col-md-12 mx-auto">
        <b-table
          id="tablePartsList" ref="tablePartsList" :items="parts"
          :fields="fields"
          :sort-by.sync="sortBy" :sort-desc.sync="sortDesc" per-page="0"
          :current-page="currentPage" :busy.sync="busy"
          condensed striped
          sort-icon-left
          show-empty
          primary-key="uuid"
          :no-local-sorting="true"
          small
          @sort-changed="sortTableChanged"
        >
          <template #cell(qrcode)="data">
            <div @click="showBigQrCode(data.item)">
              <qrcode
                :id="qrcodeId(data.item.id)"
                v-b-tooltip.hover
                :value="qrCodePart(data.item.uuid)"
                :options="{ scale: 1, color: {dark: '#000000', light:'#0000'} }"
                title="click to show bigger QrCode"
                :data-uuid="data.item.uuid"
                :data-name="data.item.name"
                data-toggle="modal"
                data-target="#modalQrCode"
              />
            </div>
          </template>

          <template #cell(name)="data">
            <a href="#" @click.prevent="viewPartModal(data.item)">{{ data.item.name }}</a>
            <br>
            <template v-if="data.item.description">
              {{ data.item.category ? data.item.category.name : 'No category' }}: {{ data.item.description }}
            </template>
            <template v-else>
              {{ data.item.category ? data.item.category.name : 'No category' }}
            </template>
          </template>

          <template #cell(storage)="data">
            {{ data.item.storage && data.item.storage.name ? data.item.storage.name : '-' }}
          </template>

          <template #cell(part_unit)="data">
            {{ data.item.part_unit && data.item.part_unit.name ? data.item.part_unit.name : '-' }}
          </template>

          <template #cell(stock_qty)="data">
            <span
              v-if="(data.item.stock_qty < data.item.stock_qty_min) || data.item.stock_qty == 0"
              class="qtyMinWarning"
            >{{ data.item.stock_qty }}
              <i
                v-b-tooltip.hover class="fa fa-circle"
                aria-hidden="true"
                title="Current stock is below minimum stock quantity or exhausted"
              />
            </span>
            <span v-else>{{ data.item.stock_qty }}</span>
          </template>

          <template #cell(stock_qty_min)="data">
            <span>{{ data.item.stock_qty_min }}</span>
          </template>

          <template #cell(footprint)="data">
            <span
              v-b-tooltip.hover
              :title="data.item.footprint ? data.item.footprint.description : ''"
            >
              {{ data.item.footprint ? data.item.footprint.name : '-' }}
            </span>
          </template>
        </b-table>
      </div>
    </div>

    <b-row>
      <b-col md="6" offset-md="1">
        <b-pagination
          v-model="currentPage"
          :total-rows="partsCount"
          :per-page="perPage"
          aria-controls="tablePartsList"
          @change="pageChanged"
        />
      </b-col>
    </b-row>
  </div>
</template>

<script>
import QRCode from 'qrcode'
import logger from '@/logging'
import { mapState } from 'vuex'
import ViewModal from '@/components/parts/view_modal'
import apiService from '@/services/api/api.service'

export default {
  components: {
    ViewModal
  },
  props: {
    category: {
      type: Object
    }
  },
  data: () => ({
    parts: [],
    currentPage: 1,
    partDetails: null,
    partsCount: 0,
    fields: [
      { key: 'qrcode', label: 'QrCode', tdClass: 'qrCode' },
      { key: 'name', label: 'Name', sortable: true },
      { key: 'storage', label: 'Storage', sortable: true },
      { key: 'stock_qty', label: 'Stock', sortable: true },
      { key: 'stock_qty_min', label: 'Min', sortable: true },
      { key: 'part_unit', label: 'Unit', sortable: true },
      { key: 'footprint', label: 'Footprint', sortable: true }
    ],
    sortBy: 'name',
    sortDesc: false,
    busy: false,
    filter: {
      footprint: null,
      storage: null,
      qty: null,
      sellable: false
    }
  }),
  computed: {
    ...mapState({
      currentCategory: state => { return state.preloads.currentCategory },
      serverSettings: state => state.server.settings,
      choicesStorageLocation: (state) => state.preloads.storages,
      choicesFootprint: (state) => {
        return state.preloads.footprints.map(x => { return { category: x.name, footprints: x.footprint_set.map(y => { return { id: y.id, name: y.name } }) } })
      },
      categories: state => { return [state.preloads.categories] }
    }),
    perPage () {
      return this.serverSettings.pagination.PARTS || 10
    },
    categoryId () {
      return this.$route.params.categoryId
    },
    storageId () {
      return this.$route.query.storage
    },
    storageUuid () {
      return this.$route.query.storage_uuid
    },
    searchQuery () {
      return this.$route.query.q
    },
    actualCurrentCategory () {
      return this.category || this.currentCategory
    }
  },
  watch: {
    'categoryId': function () {
      this.fetchParts(1, null)
      this.categoryChanged()
    },
    'searchQuery': function () {
      this.fetchParts(1, { search: this.searchQuery })
    },
    'filter.qty': function () {
      if (this.filter.qty === 'qty') {
        this.fetchParts(1, { qtyType: 'qty' })
      } else if (this.filter.qty === 'qtyMin') {
        this.fetchParts(1, { qtyType: 'qtyMin' })
      } else {
        this.fetchParts(1, null)
      }
    },
    'filter.sellable': function () {
      this.fetchParts(1, null)
    },
    'storageUuid': function () {
      this.fetchParts(1, { storage_uuid: this.storageUuid })
    }
  },
  created () {
    this.$nextTick(() => {
      if (this.searchQuery) {
        this.fetchParts(1, { search: this.searchQuery })
      } else if (this.storageUuid) {
        this.fetchParts(1, { storage_uuid: this.storageUuid })
      } else {
        this.fetchParts(1, null)
        this.categoryChanged()
      }
    })
  },
  methods: {
    categoryChanged () {
      if (!this.categoryId || Number(this.categoryId) === 0) {
        this.$store.commit('setCurrentCategory', { id: this.categoryId, name: 'none' })
        return
      }
      let curCat = null
      const cb = (e) => {
        if (e.id === Number(this.categoryId)) {
          curCat = e
        }
        e.children.forEach(cb)
      }
      this.categories.forEach(cb)
      this.$store.commit('setCurrentCategory', { id: this.categoryId, name: curCat.name })
    },
    pageChanged (page) {
      this.fetchParts(page, null)
    },
    sortTableChanged (ctx) {
      // When changing the sorting order, reset the pagination to page 1
      let opts = { ordering: ctx.sortDesc ? `-${ctx.sortBy}` : ctx.sortBy }
      this.fetchParts(1, opts)
    },
    qrcodeId (id, size) {
      return size ? `qrcode-${id}-${size}` : `qrcode-${id}`
    },
    qrCodePart (uuid) {
      return `web+stockazio:part,${uuid}`
    },
    async showBigQrCode (part) {
      let qrCodeDataUrl = await QRCode.toDataURL(this.qrCodePart(part.uuid), { width: 300 }).then((url) => { return url })

      const h = this.$createElement
      const titleVNode = h('div', { domProps: { innerHTML: `QrCode for: ${part.name}` } })
      const messageVNode = h('div', { domProps: { style: 'text-align: center;' } }, [
        h('img', { domProps: { src: qrCodeDataUrl } }),
        h('div', {}, ['The content of the QrCode is:', h('br'), h('code', { class: ['qrCodeText'] }, [this.qrCodePart(part.uuid)])])
      ])
      this.$bvModal.msgBoxOk([messageVNode], {
        title: [titleVNode],
        buttonSize: 'sm',
        centered: true,
        size: 'lg'
      })
    },
    fetchParts (page, opts) {
      let params = {
        page: page,
        size: this.perPage,
        ...opts
      }
      if (this.categoryId !== null) {
        params.category_id = this.categoryId
      }
      if (this.searchQuery) {
        params.search = this.searchQuery
      }
      if (this.storageId && !this.filter.storage) {
        params.storage_id = this.storageId
      }
      if (this.storageUuid && !this.filter.storage) {
        params.storage_uuid = this.storageUuid
      }
      if (this.filter.footprint) {
        params.footprint_id = this.filter.footprint.id
      }
      if (this.filter.qty === 'qty') {
        params.qtyType = 'qty'
      } else if (this.filter.qty === 'qtyMin') {
        params.qtyType = 'qtyMin'
      }
      if (this.filter.sellable) {
        params.sellable = true
      }

      this.busy = true
      apiService.getPublicParts(params)
        .then((res) => {
          this.parts = res.data.results
          this.partsCount = res.data.count
          this.busy = false
          // eslint-disable-next-line vue/custom-event-name-casing
          this.$root.$emit('bv::refresh::table', 'tablePartsList')
        })
    },
    viewPartModal (part) {
      apiService.getPublicPart(part.id)
        .then((val) => {
          this.partDetails = val.data
          this.$bvModal.show('modalManage')
        })
        .catch((err) => {
          this.$bvToast.toast(this.$pgettext('Part/ShowModal/Toast/Error/Message', 'An error occured, please try again later'), {
            title: this.$pgettext('Part/ShowModal/Toast/Error/Title', 'Part details'),
            autoHideDelay: 5000,
            appendToast: true,
            variant: 'danger',
            toaster: 'b-toaster-top-center'
          })
          logger.default.error('Error fetching part', err)
          this.partDetails = null
        })
    },
    storagesNormalizer: function (node) {
      let childs = (node.children || []).concat(node.storage_locations || [])
      let id = node.uuid ? node.id : `cat_${node.id}`
      return { id: id, label: node.name, children: childs && childs.length ? childs : 0 }
    },
    filterFootprintChanged (value, id) {
      if (value) {
        this.fetchParts(1, { footprint_id: value.id })
      } else {
        this.fetchParts(1, null)
      }
    },
    filterStorageChanged (value, id) {
      if (value) {
        this.fetchParts(1, { storage_id: value })
      } else {
        this.fetchParts(1, null)
      }
    },
    onPartModalClosed () {
      this.partDetails = null
    }
  }
}
</script>
